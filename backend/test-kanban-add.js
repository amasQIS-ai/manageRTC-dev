import { MongoClient, ObjectId } from "mongodb";
import {
  DEFAULT_KANBAN_COLUMNS,
  normalizeStageKey,
} from "./models/kaban/kaban.model.js";

const MONGODB_URI =
  process.env.MONGODB_URI || "mongodb://localhost:27017/?retryWrites=true";
const TEST_DB_NAME = process.env.TEST_DB_NAME || "test_hrms_kanban_add";
const TEST_COMPANY_ID =
  process.env.TEST_COMPANY_ID || "test_company_kanban_add_123";
const SKIP_CLEANUP = process.env.SKIP_KANBAN_ADD_CLEANUP === "true";

let client;
let db;
let boardsCollection;
let columnsCollection;
let cardsCollection;
let leadsCollection;
let boardDoc;
let columnDocs = [];

const divider = () => console.log("â”€".repeat(60));

async function connectDB() {
  client = new MongoClient(MONGODB_URI);
  await client.connect();
  db = client.db(TEST_DB_NAME);
  boardsCollection = db.collection("kanbanBoards");
  columnsCollection = db.collection("kanbanColumns");
  cardsCollection = db.collection("kanbanCards");
  leadsCollection = db.collection("leads");
  console.log("âœ… Connected to MongoDB");
}

async function cleanup() {
  if (SKIP_CLEANUP) {
    console.log("â­ï¸  Cleanup skipped (SKIP_KANBAN_ADD_CLEANUP=true)");
    return;
  }

  await Promise.all([
    boardsCollection.deleteMany({ companyId: TEST_COMPANY_ID }),
    columnsCollection.deleteMany({ companyId: TEST_COMPANY_ID }),
    cardsCollection.deleteMany({ companyId: TEST_COMPANY_ID }),
  ]);
  console.log("ğŸ§¹ Test data removed");
}

async function ensureBoardAndColumns() {
  const now = new Date();
  boardDoc = await boardsCollection.findOne({ companyId: TEST_COMPANY_ID });

  if (!boardDoc) {
    boardDoc = {
      _id: new ObjectId(),
      companyId: TEST_COMPANY_ID,
      name: "Kanban Add Test Board",
      description: "Board generated by kanban add test suite",
      settings: { allowBulkDrag: true, filters: {} },
      createdAt: now,
      updatedAt: now,
    };
    await boardsCollection.insertOne(boardDoc);
    console.log("ğŸ†• Board created for tests");
  } else {
    console.log("â™»ï¸  Reusing existing test board");
  }

  columnDocs = await columnsCollection
    .find({ boardId: boardDoc._id })
    .sort({ order: 1 })
    .toArray();

  if (!columnDocs.length) {
    columnDocs = DEFAULT_KANBAN_COLUMNS.map((column) => ({
      _id: new ObjectId(),
      boardId: boardDoc._id,
      companyId: TEST_COMPANY_ID,
      key: column.key,
      label: column.label,
      color: column.color,
      order: column.order,
      isSystem: true,
      createdAt: now,
      updatedAt: now,
    }));
    await columnsCollection.insertMany(columnDocs);
    console.log("ğŸ†• Default columns inserted");
  }

  return { boardDoc, columnDocs };
}

async function createLead(payload = {}) {
  const leadDoc = {
    _id: new ObjectId(),
    companyId: TEST_COMPANY_ID,
    name: payload.name || "Test Lead",
    email: payload.email || "test@example.com",
    phone: payload.phone || "+1-555-0100",
    value: payload.value ?? 100000,
    owner: payload.owner || "QA Bot",
    stage: payload.stage || "To Contact",
    country: payload.country || "USA",
    priority: payload.priority || "Medium",
    createdAt: new Date(),
    updatedAt: new Date(),
    ...payload,
  };

  await leadsCollection.insertOne(leadDoc);
  return leadDoc;
}

async function insertCardFromLead(lead, extra = {}) {
  const stageKey = normalizeStageKey(lead.stage);
  const column =
    columnDocs.find((col) => col.key === stageKey) || columnDocs[0];

  const cardDoc = {
    _id: new ObjectId(),
    boardId: boardDoc._id,
    columnId: column._id,
    columnKey: column.key,
    companyId: TEST_COMPANY_ID,
    leadId: lead._id,
    title: lead.name,
    email: lead.email,
    phone: lead.phone,
    value: lead.value,
    owner: lead.owner,
    order: Date.now(),
    createdAt: new Date(),
    updatedAt: new Date(),
    history: [],
    ...extra,
  };

  await cardsCollection.insertOne(cardDoc);
  return cardDoc;
}

async function insertManualCard(payload = {}) {
  const column = columnDocs.find((col) => col.key === payload.columnKey) || columnDocs[0];
  const cardDoc = {
    _id: new ObjectId(),
    boardId: boardDoc._id,
    columnId: column._id,
    columnKey: column.key,
    companyId: TEST_COMPANY_ID,
    title: payload.title || "Manual Card",
    company: payload.company || "Manual Inc",
    email: payload.email || "",
    phone: payload.phone || "",
    value: payload.value ?? 50000,
    owner: payload.owner || "Manual Owner",
    priority: payload.priority || "High",
    order: Date.now(),
    createdAt: new Date(),
    updatedAt: new Date(),
    history: [],
  };

  await cardsCollection.insertOne(cardDoc);
  return cardDoc;
}

async function testAddCardFromLead() {
  const lead = await createLead({
    name: "Lead Add Test",
    email: "lead.add@example.com",
    stage: "Qualified",
    value: 150000,
    owner: "Alice QA",
  });

  const card = await insertCardFromLead(lead);
  const stored = await cardsCollection.findOne({ _id: card._id });

  const success =
    stored?.leadId?.toString() === lead._id.toString() &&
    stored?.columnKey === normalizeStageKey(lead.stage);

  console.log(
    success
      ? `âœ… Card created from lead (${lead.name})`
      : "âŒ Failed to create card from lead"
  );
  return success;
}

async function testManualCardAdd() {
  const card = await insertManualCard({
    title: "Manual QA Card",
    columnKey: "proposal",
    company: "Manual QA Co",
    value: 75000,
    owner: "Bob QA",
  });

  const stored = await cardsCollection.findOne({ _id: card._id });
  const success =
    stored?.title === "Manual QA Card" && stored?.columnKey === "proposal";

  console.log(
    success
      ? "âœ… Manual card added to Proposal column"
      : "âŒ Manual card add failed"
  );
  return success;
}

async function testBoardTotalsAfterAdd() {
  const counts = await cardsCollection
    .aggregate([
      { $match: { companyId: TEST_COMPANY_ID } },
      { $group: { _id: "$columnKey", count: { $sum: 1 }, value: { $sum: "$value" } } },
      { $sort: { count: -1 } },
    ])
    .toArray();

  console.log("ğŸ“Š Current column totals after add:", counts);
  return counts.length > 0;
}

async function runKanbanAddTests() {
  divider();
  console.log("ğŸ§ª Starting Kanban ADD Test Suite");
  divider();

  try {
    await connectDB();
    await cleanup();
    await ensureBoardAndColumns();

    const tests = [
      { name: "Add card from lead", fn: testAddCardFromLead },
      { name: "Add manual card", fn: testManualCardAdd },
      { name: "Column totals after additions", fn: testBoardTotalsAfterAdd },
    ];

    const results = [];
    for (const test of tests) {
      try {
        const result = await test.fn();
        results.push({ test: test.name, result });
      } catch (error) {
        console.error(`âŒ ${test.name} crashed:`, error.message);
        results.push({ test: test.name, result: false });
      }
    }

    divider();
    console.log("ğŸ“‹ KANBAN ADD SUMMARY");
    divider();
    const passed = results.filter((r) => r.result).length;
    results.forEach(({ test, result }) =>
      console.log(`${result ? "âœ…" : "âŒ"} ${test}`)
    );
    console.log(
      `\nâœ… Passed: ${passed}/${results.length} | âŒ Failed: ${
        results.length - passed
      }`
    );
    console.log(
      `ğŸ“ˆ Success Rate: ${((passed / results.length) * 100).toFixed(1)}%`
    );
  } catch (error) {
    console.error("âŒ Kanban ADD Test Suite failed:", error);
  } finally {
    divider();
    await cleanup();
    await client?.close();
    console.log("ğŸ”Œ MongoDB connection closed");
    divider();
  }
}

runKanbanAddTests();

